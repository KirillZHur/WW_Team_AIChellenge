## Frontend README
================

### Назначение проекта
---------------------
Этот frontend реализует пользовательский интерфейс системы подготовки и согласования официальных писем на основе ИИ.

Основные задачи интерфейса:
- загрузка входящего письма (PDF/DOCX/TXT);
- задание названия генерации и стиля ответа ИИ;
- вызов REST API backend для создания сущности письма и генерации черновика ответа;
- отображение сгенерированного текста, краткого пересказа и ключевых рисков;
- возможность редактирования и копирования ответа.

Технологический стек:
- React (create-react-app, HashRouter);
- Темизация на основе Volt React Dashboard;
- UI-библиотека @themesberg/react-bootstrap;
- Работа с REST API через fetch (возможен переход на axios).


### Структура фронтенда
----------------------
Корневая папка фронта: Frontend/

Основные директории:
- Frontend/src/
  - api.js        — настройка базового URL для REST API;
  - index.js      — точка входа, подключение роутера и HomePage;
  - routes.js     — описание маршрутов (Main и Second);
  - pages/
      - MainPage.js  — экран загрузки письма и запуска генерации;
      - Second.js    — экран с сгенерированным ответом и аналитикой;
  - components/
      - Sidebar.js   — левое меню (новое письмо + список ответов);
      - Navbar.js    — верхняя панель (если используется);
      - Footer.js    — нижняя панель (если используется);
  - scss/           — стили Volt и кастомные правки.

Фронтенд использует HashRouter, поэтому маршруты имеют вид:
- #/            — MainPage (новое письмо);
- #/second      — Second (экран ответа).


### REST API: базовая конфигурация
---------------------------------
Файл: src/api.js

Используется axios.create с базовым URL, по умолчанию:
- http://localhost:8080/api/v1

Конфигурация:
- baseURL берётся из переменной окружения REACT_APP_API_BASE_URL (если задана);
- если переменная не задана, используется дефолтное значение.

Пример:
- REACT_APP_API_BASE_URL=http://localhost:8080/api/v1


### Логика MainPage (новое письмо)
---------------------------------
Файл: src/pages/MainPage.js

Главная задача страницы:
- сосредоточить пользователя на загрузке файла письма;
- задать название генерации;
- выбрать стиль ответа ИИ;
- отправить данные на backend и перейти на экран сгенерированного ответа.

Основные состояния:
- file        — выбранный File (объект браузера);
- fileName    — имя выбранного файла (строка);
- title       — название генерации (строка);
- styleId     — выбранный стиль ответа ИИ (strict / corporate / client / short);
- isDragOver  — флаг drag-and-drop зоны;
- error       — текст ошибки валидации или ошибки API;
- isSubmitting — флаг выполнения запроса к backend.

Стилевые пресеты для UI (STYLE_OPTIONS):
- strict     — строгий официальный стиль;
- corporate  — деловой корпоративный;
- client     — клиентоориентированный;
- short      — краткий информационный.

Маппинг стилей UI → значения для API (STYLE_TO_API):
- strict     → OFFICIAL_REGULATOR
- corporate  → CORPORATE
- client     → CLIENT
- short      → SHORT_INFO

Основные обработчики:
- applyFile(file):
    - сохраняет file и fileName;
    - если title пустой — подставляет имя файла без расширения.
- handleFileChange(e):
    - получает файл из input type="file" и передаёт в applyFile.
- handleDragOver / handleDragLeave / handleDrop:
    - реализация drag-and-drop зоны для загрузки файла.
- handleClear():
    - сбрасывает file, fileName, title и error.
- handleGenerate():
    1) валидация:
       - наличие файла;
       - непустое название генерации.
    2) отправка запроса на backend:
       - создаётся FormData;
       - в FormData добавляются:
         - "file"            — сам файл;
         - "title"           — строка с названием генерации;
         - "preferredStyle"  — стиль из STYLE_TO_API.
    3) выполняется запрос:
       - POST /api/v1/letters
       - тело: multipart/form-data
       - ожидаемый ответ: JSON с полем id (letterId).
    4) после успешного создания письма:
       - отправляется запрос на генерацию черновика:
         - POST /api/v1/letters/{letterId}/drafts
         - Content-Type: application/json
         - тело: { "style": "<значение из STYLE_TO_API>" }
       - ожидаемый ответ: 202 Accepted, JSON с полями:
         - id     — идентификатор черновика;
         - status — GENERATING (или другое значение по backend).
    5) после успешного ответа backend по draft:
       - выполняется переход на страницу Second:
         - маршрутизатор: history.push
         - URL: Routes.Second.path + "?letterId=<...>&draftId=<...>"

Таким образом, MainPage:
- создаёт письмо;
- запускает генерацию черновика ответа;
- перенаправляет пользователя на страницу просмотра и редактирования ответа.


### Логика Second (экран с ответом)
----------------------------------
Файл: src/pages/Second.js

Назначение страницы:
- показать сгенерированный черновик письма;
- дать возможность сменить стиль (на уровне UI);
- позволить редактировать текст;
- обеспечить копирование текста;
- компактно показать анализ письма (пересказ, риски, SLA, согласующие).

Параметры URL:
- letterId — идентификатор письма (letters);
- draftId  — идентификатор черновика (drafts).

Параметры извлекаются из query string:
- useLocation + URLSearchParams.

Основные состояния:
- styleKey        — выбранный стиль для отображения (strict/corporate/client/short);
- isEditing       — режим редактирования текста;
- text            — текст черновика;
- letterMeta      — метаданные письма (ответ сервера);
- draftMeta       — метаданные черновика;
- loading         — общий флаг загрузки;
- error           — текст ошибки;
- isRegenerating  — флаг для потенциального перегенерирования (зарезервирован).

Маппинг стилей из API → стили UI (API_STYLE_TO_KEY):
- OFFICIAL_REGULATOR → strict
- CORPORATE         → corporate
- CLIENT            → client
- SHORT_INFO        → short

Основные эффекты и запросы:
- useEffect при монтировании и при изменении letterId/draftId:
  1) проверяет наличие draftId, иначе устанавливает ошибку.
  2) если есть letterId — выполняет запрос:
     - GET /api/v1/letters/{letterId}
     - используется для формирования бейджей (адресат, SLA, тип и т.п.).
  3) выполняет загрузку черновика (функция loadDraft):
     - GET /api/v1/drafts/{draftId}
     - ответ ожидается в виде JSON с полями:
       - id
       - style
       - status (например, GENERATING или EDITABLE)
       - text (готовый текст черновика, если статус EDITABLE)
       - version (номер версии)
     - сохраняет draftMeta;
     - если есть text — устанавливает text и вычисляет styleKey через API_STYLE_TO_KEY.
  4) если статус черновика GENERATING:
     - запускается polling через setInterval (примерно каждые 2 секунды);
     - loadDraft повторно вызывается до тех пор, пока статус не перестанет быть GENERATING;
     - после успешной загрузки готового текста снимается флаг loading.

UI-команды:
- handleStyleChange(key):
  - меняет локальный styleKey.
  - если text пустой (на случай, когда сервер не вернул текст):
    - устанавливает заглушку вида: "Здесь будет текст в стиле: ...".
  - на данном этапе стиль меняется только визуально, без нового запроса к API.
- handleCopy():
  - пытается скопировать text в буфер обмена через navigator.clipboard.writeText;
  - при отсутствии поддержки — выводит текст в консоль (fallback).

Бейджи в верхней части Second:
- Адресат: берётся из letterMeta.sender (если есть);
- Тип обращения: берётся из draftMeta.letterType (если backend вернёт это поле) либо заглушка;
- SLA: берётся из letterMeta.slaAt (форматируется в локальное время);
- Отдельный бейдж: "Требуется согласование".

Правая колонка:
- Краткий пересказ (summary) — статический текст-заглушка;
- Accordion с секциями:
  - "Ключевые моменты и риски" — список рекомендаций и рисков;
  - "Автоанализ письма" — тип обращения, SLA, уровень риска, согласующие;
  - "Версии ответа" — текущая версия черновика (использует draftMeta.version).

Second таким образом:
- отображает результат генерации;
- даёт возможность отредактировать текст;
- готов к расширению (отправка на согласование, смена стиля через API, сохранение правок и т.д.).


### Sidebar (список генераций)
-----------------------------
Файл: src/components/Sidebar.js

Назначение:
- отображать навигацию по экрану "Новое письмо";
- отображать "Последний ответ";
- показывать список генераций/ответов (как список диалогов в чате).

Текущее состояние:
- использует мок-данные threads (массив объектов с id, title, status);
- заголовок секции: "Ответы";
- каждый элемент ведёт на Routes.Second.path (можно будет заменить на реальный путь с query-параметрами).

Дальнейшее развитие:
- при наличии backend-API (GET /api/v1/letters или отдельного списка сессий) threads можно заполнять реальными данными:
  - id / title / статус;
  - подсветка активного письма по текущему URL;
  - отображение SLA/иконок и т.п.


### Запуск проекта
-----------------
Требования:
- Node.js (актуальная LTS-версия);
- npm или yarn;
- запущенный backend по адресу, соответствующему настройкам REACT_APP_API_BASE_URL.

Установка зависимостей:
- cd Frontend
- npm install
  или
- yarn install

Запуск в режиме разработки:
- cd Frontend
- npm start
  или
- yarn start

По умолчанию приложение будет доступно по адресу:
- http://localhost:3000

Сборка для продакшена:
- cd Frontend
- npm run build
  или
- yarn build

Результат сборки будет в каталоге:
- Frontend/build

Важное замечание по API:
- фронтенд ожидает, что backend будет доступен по адресу,
  указанному в REACT_APP_API_BASE_URL (например http://localhost:8080/api/v1);
- конкретная реализация эндпоинтов на backend должна соответствовать
  ожидаемым путям и форматам, описанным выше (letters, drafts и т.д.).
